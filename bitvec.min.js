const WORD_ADDRESS_BITS=5,BITS_PER_WORD=32,BITMASK32=4294967295,wordIdx=t=>t>>>5,wordsOfBits=t=>wordIdx(t-1)+1,rand32=t=>4294967295*(t||Math.random)(),bitCount=t=>16843009*((t=(858993459&(t-=t>>>1&1431655765))+(t>>>2&858993459))+(t>>>4)&252645135)>>>24,trailing0s=t=>bitCount((t^t-1)>>>1);class BitVec{constructor(t){this.nbits=t||32,this.words=new Uint32Array(wordsOfBits(t))}clone(){let t=new BitVec(this.nbits);return t.words=this.words.slice(),t}bitOn(t){this._bounded(t),this._wordOr(wordIdx(t),1<<t)}bitOff(t){this._bounded(t),this._wordAnd(wordIdx(t),1<<t)}flip(t){this._bounded(t),this._wordXor(wordIdx(t),1<<t)}set(t,s){this._bounded(t),s?this.bitOn(t):this.bitOff(t)}get(t){return this._bounded(t),this.words[wordIdx(t)]>>>t&1}isOn(t){return this._bounded(t),1==this.get(t)}isOff(t){return this._bounded(t),0==this.get(t)}isAllOn(){return this.rangeIsOn(0,this.nbits)}isAllOff(){return this.rangeIsOff(0,this.nbits)}cardinality(){return this.words.reduce((t,s)=>t+=bitCount(s),0)}clear(){this.words.forEach((t,s)=>this.words[s]=0)}setAll(){this.words.forEach((t,s)=>this.words[s]=BITMASK32),this._trimMsbs()}randomize(t){this.words.forEach((s,r)=>this.words[r]=rand32(t)),this._trimMsbs()}rangeOn(t,s){this._rangeOp(t,s,this._wordOr.bind(this))}rangeOff(t,s){this._rangeOp(t,s,this._wordAnd.bind(this))}rangeFlip(t,s){this._rangeOp(t,s,this._wordXor.bind(this))}rangeIsOn(t,s){let r=!0;return this._rangeOp(t,s,(t,s)=>{r=r&&this._wordOn(t,s)}),r&&t<s}rangeIsOff(t,s){let r=!0;return this._rangeOp(t,s,(t,s)=>r=r&&this._wordOff(t,s)),r&&t<s}slice(t,s){t=t||0,s=s||this.nbits;let r=new BitVec(s-t);for(let i=t,o=0;i<s;i++,o++)r.set(o,this.get(i));return r}nextOn(t){if(t>=this.nbits||t<0)return-1;let s=wordIdx(t),r=this.words[s]&BITMASK32<<t;for(;;){if(0!=r)return 32*s+trailing0s(r);if(++s==this.wordCount)return-1;r=this.words[s]}}nextOff(t){if(t>=this.nbits||t<0)return-1;let s=wordIdx(t),r=~this.words[s]&BITMASK32<<t;for(;;){if(0!=r){let t=32*s+trailing0s(r);return t>=this.nbits?-1:t}if(++s==this.wordCount)return-1;r=~this.words[s]}}iterLsb(t){for(let s=0;s<this.nbits;s++)t(this.get(s),s)}iterMsb(t){for(let s=this.nbits-1;s>=0;s--)t(this.get(s),s)}not(){this.rangeFlip(0,this.nbits)}and(t){if(this!=t){for(let s=this.wordCount;s>=t.wordCount;s--)this.words[s]=0;for(let s=0;s<this.wordCount;s++)this.words[s]&=t.words[s]}}or(t){if(this==t)return;let s=Math.min(this.wordCount,t.wordCount);this._ensureCap(t.nbits);for(let r=0;r<s;r++)this.words[r]|=t.words[r];s<this.wordCount&&(this.words.set(t.words.slice(s),s),this._cleanseLast())}xor(t){if(this==t)return;let s=Math.min(this.wordCount,t.wordCount);this._ensureCap(t.nbits);for(let r=0;r<s;r++)this.words[r]^=t.words[r];s<this.wordCount&&(this.words.set(t.words.slice(s),s),this._cleanseLast())}andNot(t){for(let s=Math.min(this.wordCount,t.wordCount)-1;s>=0;s--)this.words[s]&=~t.words[s]}rshift(t){const s=32-(t%=32),r=(1<<t)-1;let i=0;for(let o=this.wordCount-1;o>=0;o--){let e=this.words[o]&r;this.words[o]=this.words[o]>>>t,this.words[o]|=i<<s,i=e}return i}lshift(t){const s=32-(t%=32),r=~((1<<t)-1);let i=0;for(let s=this.nbits-1;s>=this.nbits-t;s--)i=i<<1|this.get(s);let o=0;for(let i=0;i<this.wordCount;i++){let e=this.words[i]&r;this.words[i]=this.words[i]<<t,this.words[i]|=o>>>s,o=e}return i}equals(t){if(this==t)return!0;if(this.nbits!=t.nbits)return!1;let s=this.wordCount-1;for(let r=0;r<s;r++)if(this.words[r]!=t.words[r])return!1;if(s>=0){let r=BITMASK32>>>-this.nbits;if((this.words[s]&r)!=(t.words[s]&r))return!1}return!0}_rangeOp(t,s,r){if(this._bounded2(t),this._bounded2(s),t>=s)return;let i=wordIdx(t),o=wordIdx(s-1),e=BITMASK32<<t,n=BITMASK32>>>-s;if(i==o)r(i,e&n);else{r(i,e);for(let t=i+1;t<o;t++)r(t,BITMASK32);r(o,n)}}resize(t){if(this.nbits!=t)if(this.nbits<t){let s=this.words;this.nbits=t,this.words=new Uint32Array(wordsOfBits(t)),this.words.set(s,0)}else this.nbits=t,this.words=this.words.slice(0,wordsOfBits(t)),this._cleanseLast()}toString(){return this.asBinary()}asBinary(){let t=[];return this.iterMsb(s=>t.push(s)),t.join("")}asHex(){return[...this.words].map(t=>t.toString(16).padStart(8,"0")).reverse().join("")}static ofBinary(t){let s=t.length,r=new BitVec(s);for(let i=0;i<s;i++)r.set(s-i-1,"1"==t.charAt(i));return r}static ofHex(t){let s=[],r=t.length,i=r;for(;i>0;){i=r>=8?r-8:0;let o=parseInt(t.slice(i,r),16);if(isNaN(o))throw Error("Invalid hexadecimal character.");s.push(o),r-=8}let o=new BitVec;return o.nbits=32*s.length,o.words=Uint32Array.from(s),o}get size(){return this.nbits}get wordCount(){return this.words.length}_wordBits(){return 32*this.wordCount}_trimMsbs(){this.rangeOff(this.nbits,this._wordBits())}_wordOr(t,s){this.words[t]|=s}_wordAnd(t,s){this.words[t]&=~s}_wordXor(t,s){this.words[t]^=s}_wordOn(t,s){return(this.words[t]&s)==(BITMASK32&s)}_wordOff(t,s){return 0==(this.words[t]&s)}_bounded(t){if(t<0||t>=this.nbits)throw Error("Bit index is out of bound")}_bounded2(t){if(t<0||t>this._wordBits())throw Error("Bit index is out of bound")}_ensureCap(t){this.nbits<t&&this.resize(t)}_cleanseLast(){let t=wordIdx(this.nbits-1),s=BITMASK32>>>-this.nbits;this._wordAnd(t,~s)}}export{BitVec};