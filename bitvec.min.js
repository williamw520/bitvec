const WORD_ADDRESS_BITS=5,BITS_PER_WORD=32,BIT_INDEX_MASK=31,BITMASK32=4294967295,wordIdx=t=>t>>>5,wordsOfBits=t=>wordIdx(t-1)+1,rand32=()=>4294967295*Math.random(),bitCount=t=>16843009*((t=(858993459&(t-=t>>>1&1431655765))+(t>>>2&858993459))+(t>>>4)&252645135)>>>24,trailing0s=t=>bitCount((t^t-1)>>>1);export class BitVec{constructor(t){this.nbits=t||32,this.words=new Uint32Array(wordIdx(t-1)+1)}bitOn(t){this._bounded(t),this._wordOr(wordIdx(t),1<<t)}bitOff(t){this._bounded(t),this._wordAnd(wordIdx(t),1<<t)}flip(t){this._bounded(t),this._wordXor(wordIdx(t),1<<t)}set(t,r){this._bounded(t),r?this.bitOn(t):this.bitOff(t)}get(t){return this._bounded(t),this.words[wordIdx(t)]>>>t&1}isOn(t){return this._bounded(t),1==this.get(t)}isOff(t){return this._bounded(t),0==this.get(t)}cardinality(){return this.words.reduce((t,r)=>t+=bitCount(r),0)}clear(){this.words.forEach((t,r)=>this.words[r]=0)}setAll(){this.words.forEach((t,r)=>this.words[r]=BITMASK32),this._trimMsbs()}randomize(){this.words.forEach((t,r)=>this.words[r]=4294967295*Math.random()),this._trimMsbs()}rangeOn(t,r){this._rangeOp(t,r,this._wordOr.bind(this))}rangeOff(t,r){this._rangeOp(t,r,this._wordAnd.bind(this))}rangeFlip(t,r){this._rangeOp(t,r,this._wordXor.bind(this))}nextOn(t){let r=wordIdx(t),i=this.words[r]&BITMASK32<<t;for(;;){if(0!=i)return 32*r+trailing0s(i);if(++r==this._wordCount())return-1;i=this.words[r]}}nextOff(t){let r=wordIdx(t);if(r>=this._wordCount())return t;let i=~this.words[r]&BITMASK32<<t;for(;;){if(0!=i)return 32*r+trailing0s(i);if(++r==this._wordCount())return 32*this._wordCount();i=~this.words[r]}}iterLsb(t){for(let r=0;r<this.nbits;r++)t(this.get(r),r)}iterMsb(t){for(let r=this.nbits-1;r>=0;r--)t(this.get(r),r)}_rangeOp(t,r,i){if(this._bounded2(t),this._bounded2(r),t>=r)return;let s=wordIdx(t),o=wordIdx(r-1),d=BITMASK32<<t,n=BITMASK32>>>-r;if(s==o)i(s,d&n);else{i(s,d);for(let t=s+1;t<o;t++)i(t,BITMASK32);i(o,n)}}equals(t){if(this==t)return!0;if(this.nbits!=t.nbits)return!1;let r=this._wordCount()-1;for(let i=0;i<r;i++)if(this.words[i]!=t.words[i])return!1;if(r>=0){let i=BITMASK32>>>-this.nbits;if((this.words[r]&i)!=(t.words[r]&i))return!1}return!0}toString(){return this.asBinary()}asBinary(){let t=[];return this.iterMsb(r=>t.push(r)),t.join("")}asHex(){return[...this.words].map(t=>t.toString(16).padStart(8,"0")).reverse().join("")}static ofBinary(t){let r=t.length,i=new BitVec(r);for(let s=0;s<r;s++)i.set(r-s-1,"1"==t.charAt(s));return i}static ofHex(t){let r=[],i=t.length,s=i;for(;s>0;){s=i>=8?i-8:0;let o=parseInt(t.slice(s,i),16);if(isNaN(o))throw Error("Invalid hexadecimal character.");r.push(o),i-=8}let o=new BitVec;return o.nbits=32*r.length,o.words=Uint32Array.from(r),o}_wordCount(){return this.words.length}_wordBits(){return 32*this._wordCount()}_trimMsbs(){this.rangeOff(this.nbits,this._wordBits())}_wordOr(t,r){this.words[t]|=r}_wordAnd(t,r){this.words[t]&=~r}_wordXor(t,r){this.words[t]^=r}_bounded(t){if(t<0||t>=this.nbits)throw Error("Bit index is out of bound")}_bounded2(t){if(t<0||t>this._wordBits())throw Error("Bit index is out of bound")}}