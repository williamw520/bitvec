!function(t){"use strict";const r=t=>t>>>5,i=t=>16843009*((t=(858993459&(t-=t>>>1&1431655765))+(t>>>2&858993459))+(t>>>4)&252645135)>>>24,s=t=>i((t^t-1)>>>1);class e{constructor(t){this.nbits=t||32,this.words=new Uint32Array(r(t-1)+1)}bitOn(t){this._bounded(t),this._wordOr(r(t),1<<t)}bitOff(t){this._bounded(t),this._wordAnd(r(t),1<<t)}flip(t){this._bounded(t),this._wordXor(r(t),1<<t)}set(t,r){this._bounded(t),r?this.bitOn(t):this.bitOff(t)}get(t){return this._bounded(t),this.words[r(t)]>>>t&1}isOn(t){return this._bounded(t),1==this.get(t)}isOff(t){return this._bounded(t),0==this.get(t)}cardinality(){return this.words.reduce((t,r)=>t+=i(r),0)}clear(){this.words.forEach((t,r)=>this.words[r]=0)}setAll(){this.words.forEach((t,r)=>this.words[r]=4294967295),this._trimMsbs()}randomize(){this.words.forEach((t,r)=>this.words[r]=4294967295*Math.random()),this._trimMsbs()}rangeOn(t,r){this._rangeOp(t,r,this._wordOr.bind(this))}rangeOff(t,r){this._rangeOp(t,r,this._wordAnd.bind(this))}rangeFlip(t,r){this._rangeOp(t,r,this._wordXor.bind(this))}nextOn(t){let i=r(t),e=this.words[i]&4294967295<<t;for(;;){if(0!=e)return 32*i+s(e);if(++i==this._wordCount())return-1;e=this.words[i]}}nextOff(t){let i=r(t);if(i>=this._wordCount())return t;let e=~this.words[i]&4294967295<<t;for(;;){if(0!=e)return 32*i+s(e);if(++i==this._wordCount())return 32*this._wordCount();e=~this.words[i]}}iterLsb(t){for(let r=0;r<this.nbits;r++)t(this.get(r),r)}iterMsb(t){for(let r=this.nbits-1;r>=0;r--)t(this.get(r),r)}_rangeOp(t,i,s){if(this._bounded2(t),this._bounded2(i),t>=i)return;let e=r(t),o=r(i-1),n=4294967295<<t,d=4294967295>>>-i;if(e==o)s(e,n&d);else{s(e,n);for(let t=e+1;t<o;t++)s(t,4294967295);s(o,d)}}equals(t){if(this==t)return!0;if(this.nbits!=t.nbits)return!1;let r=this._wordCount()-1;for(let i=0;i<r;i++)if(this.words[i]!=t.words[i])return!1;if(r>=0){let i=4294967295>>>-this.nbits;if((this.words[r]&i)!=(t.words[r]&i))return!1}return!0}toString(){return this.asBinary()}asBinary(){let t=[];return this.iterMsb(r=>t.push(r)),t.join("")}asHex(){return[...this.words].map(t=>t.toString(16).padStart(8,"0")).reverse().join("")}static ofBinary(t){let r=t.length,i=new e(r);for(let s=0;s<r;s++)i.set(r-s-1,"1"==t.charAt(s));return i}static ofHex(t){let r=[],i=t.length,s=i;for(;s>0;){s=i>=8?i-8:0;let e=parseInt(t.slice(s,i),16);if(isNaN(e))throw Error("Invalid hexadecimal character.");r.push(e),i-=8}let o=new e;return o.nbits=32*r.length,o.words=Uint32Array.from(r),o}_wordCount(){return this.words.length}_wordBits(){return 32*this._wordCount()}_trimMsbs(){this.rangeOff(this.nbits,this._wordBits())}_wordOr(t,r){this.words[t]|=r}_wordAnd(t,r){this.words[t]&=~r}_wordXor(t,r){this.words[t]^=r}_bounded(t){if(t<0||t>=this.nbits)throw Error("Bit index is out of bound")}_bounded2(t){if(t<0||t>this._wordBits())throw Error("Bit index is out of bound")}}"function"==typeof define&&define.amd?define([],(function(){return e})):"object"==typeof exports?(Object.defineProperty(e,"__esModule",{value:!0}),e.default=e,e.BitVec=e,module.exports=e):t.BitVec=e}(this);